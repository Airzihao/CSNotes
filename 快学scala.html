<!DOCTYPE html>
<html>
<head>
<title>快学scala.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h2 id="%E7%AC%AC2%E7%AB%A0%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84%E5%92%8C%E5%87%BD%E6%95%B0">第2章控制结构和函数</h2>
<h3 id="21-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F">2.1 条件表达式</h3>
<pre class="hljs"><code><div>if(x&gt;0) 1 else -1
val s = if(x&gt;0) 1 else -1
if(x&gt;0) 1 else ()
</div></code></pre>
<h3 id="22-%E8%AF%AD%E5%8F%A5%E7%BB%88%E6%AD%A2">2.2 语句终止</h3>
<p>分号，同一行写多条语句时必须有，其他情况可有可无。</p>
<h3 id="23-%E5%9D%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%B5%8B%E5%80%BC">2.3 块表达式和赋值</h3>
<p>{}块包含一系列表达式，其结果也是一个表达式。块中最后一个表达式的值就是块的值。</p>
<pre class="hljs"><code><div>val distance = {val dx=x-x0; val dy=y-y0; sqrt(dx*dx + dy*dy)}
</div></code></pre>
<p>scala中赋值动作本身返回值是，Unit</p>
<h3 id="24-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA">2.4 输入和输出</h3>
<p>输出：</p>
<pre class="hljs"><code><div>print()
println()

//插值器：
printf(f&quot;Hello, $name! In six months, you'll be ${age + 0.5}%7.2f years old.%n)
</div></code></pre>
<p>输入：</p>
<pre class="hljs"><code><div>import scala.io
val name = StdIn.readLine(&quot;Your name: &quot;)

//其他方法：
readInt(),readDouble()等
</div></code></pre>
<h3 id="25%E5%BE%AA%E7%8E%AF">2.5循环</h3>
<p>Scala有while没有for。</p>
<pre class="hljs"><code><div>// 下式让i遍历表达式的所有值
for(i &lt;- 表达式)

for(i &lt;- 0 to s.length-1)
for(ch &lt;- &quot;Hello&quot;)
</div></code></pre>
<h3 id="26-%E9%AB%98%E7%BA%A7for%E5%BE%AA%E7%8E%AF">2.6 高级for循环</h3>
<pre class="hljs"><code><div>//多个生成器
for(i &lt;- 1 to 3; j &lt;- 1 to 3) println(i+j)

//每个生成器都可以带守卫
for(i &lt;- 1 to 3; j &lt;- 1 to 3 if i!=j) prinln(i+j)

//for推导式
for(i &lt;- 1 to 10) yield i%3
//交出 Vector（1,2,0,1,2,0,1,2,0,1）
</div></code></pre>
<p>另：上述生成器、守卫和定义也可写在花括号中。</p>
<h3 id="27-%E5%87%BD%E6%95%B0">2.7 函数</h3>
<pre class="hljs"><code><div>def abs(x: Double) = if (x&gt;=0) x else -x

//对于递归函数，必须指定返回类型。
def fac(n:Int): Int = if(n&lt;=0) 1 else n*fac(n-1)
</div></code></pre>
<p>Scala中不提倡使用return。</p>
<h3 id="28-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E5%B8%A6%E5%90%8D%E5%8F%82%E6%95%B0">2.8 默认参数和带名参数</h3>
<p>带名参数不需要跟参数列表的顺序完全一致。</p>
<h3 id="29-%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0">2.9 变长参数</h3>
<pre class="hljs"><code><div>def sum(args: Int*) = {
    val result = 0;
    for(arg &lt;- args) result += arg
    result
}

//加上 _* 告诉编译器希望这个参数被当作参数序列使用
val s = sum(1 to 5: _*) 
</div></code></pre>
<h3 id="210-%E8%BF%87%E7%A8%8B">2.10 过程</h3>
<p>如果函数体包含在花括号中且没有前边的=号，那么返回类型就是Unit，这样的函数被称为过程（procudure）。</p>
<pre class="hljs"><code><div>def box(s: String) = {
    ...
}
//可以显式地声明Unit返回类型。
def box(s: Stromg): Unit = {
    ...
}
</div></code></pre>
<h3 id="211-%E6%87%92%E5%80%BC">2.11 懒值</h3>
<p>在变量首次被调用时取值：</p>
<pre class="hljs"><code><div>lazy val words = scala.io.Source.fromFile(&quot;./words&quot;).mkString
</div></code></pre>
<p>lazy val对于开销较大的初始化语句比较有用。</p>
<h3 id="212-%E5%BC%82%E5%B8%B8">2.12 异常</h3>
<pre class="hljs"><code><div>if (x&gt;=0) {
    sqrt(x)
} else throw new IllegalArgumentException(&quot;x should not be negative&quot;)
</div></code></pre>
<p>更通用的异常要放在更具体的异常之后。</p>
<p>try/finally语句可以释放资源，不论有没有异常发生。finally语句不论是否抛出异常都会被执行。</p>
<h2 id="%E7%AC%AC3%E7%AB%A0-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C">第3章. 数组相关操作</h2>
<h5 id="%E8%A6%81%E7%82%B9%EF%BC%9A">要点：</h5>
<ul>
<li>Array VS. ArrayBuffer</li>
<li>提供具体初始值时不使用new</li>
<li>用()访问元素</li>
<li>for (elem &lt;- arr)</li>
<li>for (elem &lt;- arr if ...) yield ... #将原数组转型为新数组</li>
</ul>
<h3 id="31-%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84">3.1 定长数组</h3>
<pre class="hljs"><code><div>val nums = new Array[Int](10)
val a = new Array[String](10)
val a = Array(&quot;Hello&quot;,&quot;world&quot;)
s(0) = &quot;hello&quot;
</div></code></pre>
<h3 id="32-%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84%EF%BC%9A%E6%95%B0%E7%BB%84%E7%BC%93%E5%86%B2">3.2 变长数组：数组缓冲</h3>
<pre class="hljs"><code><div>import scala.collection.mutable.ArrayBuffer
val b = ArrayBuffer[Int]()
b += 1 //在结尾追加元素
b += (1,2,3) //在尾端添加多个元素
b ++= Array(8,13,21) //在尾端追加集合
b.trimEnd(2) //移除最后两个元素
b.insert(2,6,7,8) //在b(2)插入6，7，8
b.insert(2) //移除b(2)
b.insert(2,3) //从b(2)开始，移除3个元素
b.toArray //将b转换为数组
a.toBuffer //将数组a转换为数组缓冲
</div></code></pre>
<h3 id="33-%E9%81%8D%E5%8E%86array%E5%92%8Carraybuffer">3.3 遍历Array和ArrayBuffer</h3>
<pre class="hljs"><code><div>for (i &lt;- 0 until a.length) println(a(i))
for (i &lt;- 0 until a.length by 2) print(a(i) //两个元素一跳
for (elem &lt;- a)
0 until a.length by -1 //从数组的尾端开始
</div></code></pre>
<p>until和to方法很像，但是until方法会排除最后一个元素。</p>
<h3 id="34-%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2">3.4 数组转换</h3>
<pre class="hljs"><code><div>val a = Array(2,3,5,7,11)
val result = for(elem &lt;- a) yield 2*elem
    // resule = (3,6,10,14,22)

for(elem &lt;- a if elem % 2 == 0) yield 2*elem    
另一种做法：
a.filter(_ % 2 == 0).map(2 * _)
//或
a filter{_ % 2 == 0} map {2 * _}
</div></code></pre>
<p>for/yeild循环创建了一个类型与原始集合相同的新集合，并且不影响原始集合。</p>
<h3 id="35-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">3.5 常用算法</h3>
<pre class="hljs"><code><div>val a = Array(1,2,3)
a.sum 
a.max
val aSorted = a.sorted //a的值并没有被改变
val aDescending = a.sortWith(_ &gt; _)
scala.util.Sorting.quickSort(a) //快排
</div></code></pre>
<pre class="hljs"><code><div>a.mkString(&quot; and &quot;) //将数组a字符串化，指定分隔
a.mkString(&quot;&lt;&quot;,&quot;,&quot;,&quot;&gt;&quot;) //指定前缀、分隔符、后缀
</div></code></pre>
<h3 id="37-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">3.7 多维数组</h3>
<pre class="hljs"><code><div>val matrix = Array.ofDim[Double](3,4) //三行四列
matrix(row)(column) = 42
</div></code></pre>
<h2 id="%E7%AC%AC4%E7%AB%A0-%E6%98%A0%E5%B0%84%E5%92%8C%E5%85%83%E7%BB%84">第4章 映射和元组</h2>
<h3 id="41-%E6%9E%84%E9%80%A0%E6%98%A0%E5%B0%84">4.1 构造映射</h3>
<pre class="hljs"><code><div>//不可变映射
val scores = Map(&quot;Alice&quot;-&gt; 10, &quot;Bob&quot;-&gt;3)
//可变映射
val scores = scala.collection.mutable.Map(&quot;Alice&quot;-&gt; 10, &quot;Bob&quot;-&gt;3)
</div></code></pre>
<h3 id="42-%E8%8E%B7%E5%8F%96%E6%98%A0%E5%B0%84%E4%B8%AD%E7%9A%84%E5%80%BC">4.2 获取映射中的值</h3>
<pre class="hljs"><code><div>//使用()表示法：如果该键不存在，则抛出异常。
val bobScore = scores(&quot;Bob&quot;) //类似于Java中的scores.get(&quot;Bob&quot;)
</div></code></pre>
<pre class="hljs"><code><div># contains方法
scores.contains(&quot;Bob&quot;)
//如下两个表达式等效
val bobScore = if(scores.contains(&quot;Bob&quot;)) scores(&quot;Bob&quot;) eles 0
val bobScore = scores.getOrElse(&quot;Bob&quot;,0)
</div></code></pre>
<pre class="hljs"><code><div>映射.get($key)这样的方法返回一个Option对象，要么是Some（键对应的值），要么是None。
</div></code></pre>
<h3 id="43-%E6%9B%B4%E6%96%B0%E6%98%A0%E5%B0%84%E4%B8%AD%E7%9A%84%E5%80%BC">4.3 更新映射中的值</h3>
<pre class="hljs"><code><div>scores(&quot;Bob&quot;) = 10
scores += (&quot;Bob&quot; -&gt; 10, &quot;Fred&quot; -&gt; 7)
score -= &quot;Alice&quot; //移除某个k-v对
</div></code></pre>
<p>如果想修改一个不可变的映射，那就只能获取一个包含所需要的更新的新映射：</p>
<pre class="hljs"><code><div>val newScores = scores + (&quot;Bob&quot; -&gt; 10, &quot;Fred&quot; -&gt; 7)
val newScores = scores - &quot;Alice&quot;
</div></code></pre>
<h3 id="44-%E8%BF%AD%E4%BB%A3%E6%98%A0%E5%B0%84">4.4 迭代映射</h3>
<p>可以使用下边的方法迭代处理映射</p>
<pre class="hljs"><code><div>for( (k,v) &lt;- 映射) 处理kv

scores.keySet //返回一个包含所有key值的集合
scores.values //返回所有value的集合

for( (k,v) &lt;- 映射&gt;) yield (v,k) //反转一个映射
</div></code></pre>
<h3 id="45-%E5%B7%B2%E6%8E%92%E5%BA%8F%E6%98%A0%E5%B0%84">4.5 已排序映射</h3>
<p>Scala中映射的实现有哈希表（默认）和平衡树两种。</p>
<pre class="hljs"><code><div>//得到一个不可变的树形映射
val scores = scala.collection.immutable.SortedMap(&quot;Alice&quot; -&gt; 10, &quot;Bob&quot; -&gt; 3)
</div></code></pre>
<h3 id="46-%E4%B8%8Ejava%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C">4.6 与Java的互操作</h3>
<p>相互转换：</p>
<pre class="hljs"><code><div>// Java转Scala
import scala.collection.JavaConversion.mapAsScalaMap
val scores: scala.collection.mutable.Map[String, Int] = new java.util.TreeMap[String, Int]

//从Properties到Map[String,String]的转换
import scala.collection.JavaConversion.propertiesAsScalaMap
val props: scala.collection.mutable.Map[String, String] = System.getProperties()
</div></code></pre>
<pre class="hljs"><code><div>//Scala 转 Java
import scala.collection.JavaConversion.mapAsJavaMap
import java.awt.font.TextAttribute._
val attrs = Map(&quot;FAMILY&quot; -&gt; &quot;Serif&quot;)
val font = new java.awt.Font(attrs)
</div></code></pre>
<h3 id="47-%E5%85%83%E7%BB%84tuple">4.7 元组(Tuple)</h3>
<p>元组是不同类型的值的聚集（同一类型都用数组了）</p>
<pre class="hljs"><code><div>#元组下标从1开始，不是从0开始
val t = (1, 3.14, &quot;red&quot;)
val second = t._2 //或： val second = t _2

//反过来赋值：
val (first, second, third) = t
val (first, second, _) = t
</div></code></pre>
<p>元组可以用于函数需要返回不止一个值的情况</p>
<h3 id="48-%E6%8B%89%E9%93%BE%E6%93%8D%E4%BD%9C">4.8 拉链操作</h3>
<pre class="hljs"><code><div>val symbols = Array(&quot;&lt;&quot;, &quot;-&quot;, &quot;&gt;&quot;)
val counts = Array(2, 10 ,2)
val pairs = symbols.zip(counts)
//输出对偶数组：
Array((&quot;&lt;&quot;,2),(&quot;-&quot;,10),(&quot;&gt;&quot;,2))
</div></code></pre>
<p>用toMap方法可以将对偶的集合转换成映射</p>
<pre class="hljs"><code><div>keys.zip(values).toMap
</div></code></pre>
<h2 id="%E7%AC%AC5%E7%AB%A0-%E7%B1%BB">第5章 类</h2>
<h3 id="51-%E7%AE%80%E5%8D%95%E7%B1%BB%E5%92%8C%E6%97%A0%E5%8F%82%E6%96%B9%E6%B3%95">5.1 简单类和无参方法</h3>
<p>在Scala中类不声明为public。Scala源文件可以包含多个类，所有这些类都有公有可见性。</p>
<pre class="hljs"><code><div>class Counter{
    private var value = 0
    def increment(){ value += 1}
    def current() = value
}

val myCounter = new Couner //或 new Counter()
myCounter.increment()
println(myCounter.current)
</div></code></pre>
<p>调用无参方法加不加括号都行，通常改值器方法加括号，取值器方法不加括号。</p>
<h3 id="52-%E5%B8%A6getter%E5%92%8Csetter%E7%9A%84%E5%B1%9E%E6%80%A7">5.2 带getter和setter的属性</h3>
<p>在Scala中，属性x的getter和setter方法分别叫做 x和x_ = 。</p>
<p>自定义getter和setter方法：</p>
<pre class="hljs"><code><div>class Person{
    private var privateAge = 0
    
    def age = privateAge
    def age_ = (newValue: Int){
        if(newValue&gt;privateAge) privateAge = newValue
    }
    
}
</div></code></pre>
<p>如果字段是私有的，则getter和setter方法也是私有的。</p>
<p>如果字段是val，则只有getter方法被生成。</p>
<h3 id="53-%E5%8F%AA%E5%B8%A6getter%E7%9A%84%E5%B1%9E%E6%80%A7">5.3 只带getter的属性</h3>
<p>在实现属性时，有如下四个选择：</p>
<ol>
<li>var foo: Scala自动生成setter和getter</li>
<li>val foo: Scala自动生成一个getter</li>
<li>自定义 foo和foo_= 方法</li>
<li>自定义 foo方法</li>
</ol>
<p>当在Scala中出现字段时，它默认是一个私有字段，加上了getter方法和setter方法。</p>
<h3 id="54-%E5%AF%B9%E8%B1%A1%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5">5.4 对象私有字段</h3>
<pre class="hljs"><code><div>private[this] var value = 0 //访问someObject.value将不被允许
</div></code></pre>
<p>用private声明的字段可以用someObject.value的方法访问，用private[this]声明的字段则只可以被该对象访问。</p>
<h3 id="55-bean%E5%B1%9E%E6%80%A7">5.5 Bean属性</h3>
<pre class="hljs"><code><div>class Person{
    @BeanProperty var name: String = _
}
</div></code></pre>
<p>将会生成四个方法：</p>
<ol>
<li>name: String</li>
<li>name_: Unit</li>
<li>getName(): String</li>
<li>setName(newValue: String): Unit</li>
</ol>
<h3 id="56-%E8%BE%85%E5%8A%A9%E6%9E%84%E9%80%A0%E5%99%A8">5.6 辅助构造器</h3>
<ol>
<li>辅助构造器的名称为this</li>
<li>每一个辅助构造器必须以对一个先前已定义的辅助构造器或主构造器的调用开始</li>
</ol>
<p>例：</p>
<pre class="hljs"><code><div>class Person {
    private var name = &quot;&quot;
    private vat age = 0
    
    def this(name: String) {  //一个辅助构造器
        this()  //调用主构造器
        this.name = name
    }
    
    def this(name:String, age:Int) {
        this(name) //调用前一个辅助构造器
        this.age = age
    }
    
}

</div></code></pre>
<h3 id="57-%E4%B8%BB%E6%9E%84%E9%80%A0%E5%99%A8">5.7 主构造器</h3>
<ol>
<li>主构造器的参数直接放置在类名之后。</li>
</ol>
<pre class="hljs"><code><div>class Person(val name: String, val age: Int) {
    // ()中的内容就是主构造器的参数
}
</div></code></pre>
<ol start="2">
<li>主构造器会执行类定义中的所有语句。</li>
</ol>
<p>一个类如果没有显式定义主构造器，则自动拥有一个无参的主构造器。这样的一个构造器仅仅执行类体中的所有语句。</p>
<h3 id="58-%E5%B5%8C%E5%A5%97%E7%B1%BB">5.8 嵌套类</h3>
<p>在类中可以定义类。要构建一个新的内部对象，只需要new这个类名。</p>
<h2 id="%E7%AC%AC6%E7%AB%A0-%E5%AF%B9%E8%B1%A1">第6章 对象</h2>
<h5 id="%E6%9C%AC%E7%AB%A0%E8%A6%81%E7%82%B9%EF%BC%9A">本章要点：</h5>
<ol>
<li>用对象作为单例或存放工具方法</li>
<li>类可以拥有一个同名的伴生对象</li>
<li>对象可以扩展类或特质</li>
<li>对象的apply方法通常用来构造伴生类的新实例</li>
<li>可以用扩展App特质的对象来避免显式定义main方法</li>
<li>通过扩展Ebyneration对象来实现枚举。</li>
</ol>
<h3 id="61-%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1">6.1 单例对象</h3>
<pre class="hljs"><code><div>object Accounts{
    private var lastNumber=0;
    def newUniqueNumber() = {  lastNumber += 1;  lastNumber}
}
</div></code></pre>
<p>对象的构造器在该对象<strong>第一次被使用时调用</strong>。对象本质上可以拥有类的所有特性，甚至可以扩展其他类或特质，但是不能提供构造器参数。</p>
<h3 id="62-%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1">6.2 伴生对象</h3>
<p>既有实例方法又有静态方法的类/</p>
<h2 id="%E7%AC%AC7%E7%AB%A0-%E5%8C%85%E5%92%8C%E5%BC%95%E5%85%A5">第7章 包和引入</h2>
<h5 id="%E6%9C%AC%E7%AB%A0%E8%A6%81%E7%82%B9%EF%BC%9A">本章要点：</h5>
<ol>
<li>包也可以像内部类那样嵌套</li>
<li>包路径不是绝对路径</li>
<li>包声明链x.y.z不自动将中间包变为可见</li>
<li>位于文件顶部不带花括号的包声明在整个文件范围内有效</li>
<li>包对象可以持有函数和变量</li>
<li>引入语句可以引入package,class,pbject</li>
<li>引入语句可以出现在任何地方位置（但最好写在文件最上方）</li>
<li>引入语句可以重命名和隐藏特定成员</li>
</ol>
<h3 id="71-%E5%8C%85">7.1 包</h3>
<p>同一个包可以定义在多个文件当中，也可以在同一个文件中为多个包贡献内存。</p>
<h3 id="72-%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99">7.2 作用域规则</h3>
<p>尽量避免用scala、java、com、org等名称来命名嵌套的包，防止发生歧义</p>
<h3 id="73-%E4%B8%B2%E8%81%94%E5%BC%8F%E5%8C%85%E8%AF%AD%E5%8F%A5">7.3 串联式包语句</h3>
<h3 id="74-%E6%96%87%E4%BB%B6%E9%A1%B6%E9%83%A8%E6%A0%87%E8%AE%B0%E6%B3%95">7.4 文件顶部标记法</h3>
<p>常用的写法
package com.horstmann,impatient
package people</p>
<h3 id="75-%E5%8C%85%E5%AF%B9%E8%B1%A1">7.5 包对象</h3>
<p>package 可以包含class、object和trait，但不能包含函数或变量的定义（这是Java虚拟机的局限）。</p>
<p>尽量把工具函数或常量添加到包而不是某个Utils对象，这样比较合理。</p>
<p>每个包都可以有一个包对象，需要在其父包中定义，且名称与子包一致，如：</p>
<pre class="hljs"><code><div>package com.horstmann.impatient

package object people{
    val defaultName = &quot;John&quot;
}

package people {
    class Person {
        var name = defaultName //从包对象拿到的常量
    }
}
</div></code></pre>
<p>注意defaultName不需要加限定词，因为它们位于同一个包内。在其他位置，这个常量可以用完全路径(com.horstmann.impatient.people.defaultName)访问到。</p>
<p>包对象被编译成有静态方法和字段的JVM类，名为package.class，</p>
<h3 id="76-%E5%8C%85%E5%8F%AF%E8%A7%81%E6%80%A7">7.6 包可见性</h3>
<p>没有被声明为public、private或protected的类成员在包含该类的包中可见</p>
<p>以下方法在它自己的包中可见：</p>
<pre class="hljs"><code><div>package com.horstmann.impatient.people

class Person{
    private[people] def description = &quot;A person with name&quot; + name
}
// 上边方法的可见度可以延展到上层包
class Person{
    private[impatient] def description = &quot;A person with name&quot; + name
}

</div></code></pre>
<h3 id="77-%E5%BC%95%E5%85%A5">7.7 引入</h3>
<p>引入某个包的全部成员：
<code>import java.awt._</code></p>
<p>引入语句可以在任何地方不仅限于文件顶部，import语句的效果一直延伸到<strong>包含该语句的块末尾</strong>。</p>
<p>如果想要引入包中的几个成员，可以使用selector：
<code>import java.awt.{Color, Font}</code></p>
<p>此方法允许重命名选择的成员：</p>
<pre class="hljs"><code><div>import java.util.{HashMap =&gt; JavaHashMap}
import scala.collection.mutable._
</div></code></pre>
<p>这样JavaHashMap对应java.util.HashMap，而HashMap则对应scala.collection.mutable.HashMap。</p>
<p>用 =&gt; _ 将某个成员隐藏：</p>
<pre class="hljs"><code><div>import java.util.{HashMap =&gt; _, _}
import scala.collection.mutable._
</div></code></pre>
<h2 id="%E7%AC%AC8%E7%AB%A0-%E7%BB%A7%E6%89%BF">第8章 继承</h2>
<p>本章要点：</p>
<ol>
<li>extends、final关键字与Java中相同。</li>
<li>重写方法时必须用override</li>
<li>只有主构造器可以调用超类的主构造器</li>
<li>可以重写字段</li>
</ol>
<h3 id="81-%E6%89%A9%E5%B1%95%E7%B1%BB">8.1 扩展类</h3>
<pre class="hljs"><code><div>class Employee extends Person{
    val salary =0.0
}
</div></code></pre>
<p>在定义中给出子类需要而超类没有的字段和方法（或者重写）。</p>
<p>将类、方法或字段声明为final，它就不能被重写。（不同于Java，Java中final字段是不可变的。）</p>
<h3 id="82-%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95">8.2 重写方法</h3>
<p>重写非抽象方法必须使用override</p>
<pre class="hljs"><code><div>public class Person{
    ...
    override def toString = getClass.getName + &quot;[name=+ + name + &quot;]&quot;
}
</div></code></pre>
<p>override可在如下情况中给出有用的错误提示：</p>
<ol>
<li>拼错了要重写的方法名。</li>
<li>在新方法中使用了错误的参数类型。</li>
<li>在超类中引入了新的方法，这个方法与子类的方法相冲突。</li>
</ol>
<p>上述第三点实际是<strong>易违约基类问题</strong>的体现：程序员甲写了基类A，程序员乙在甲不知情的情况下，定义了子类B，在B中实现了一个名为a的方法。后来甲又在A中添加了名为a的方法。当乙运行的时候，很可能出错。</p>
<h3 id="83-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%92%8C%E8%BD%AC%E6%8D%A2">8.3 类型检查和转换</h3>
<p>isInstanceOf和asInstanceOf</p>
<pre class="hljs"><code><div>if (p.isInstanceOf[Employee]){
    val s = p.asInstanceOfp[Employee] //s的类型为Employee
}
</div></code></pre>
<table>
<thead>
<tr>
<th>条件</th>
<th>isInstanceOf</th>
<th>asInstanceOf</th>
</tr>
</thead>
<tbody>
<tr>
<td>Employee类及其子类</td>
<td>true</td>
<td>正常</td>
</tr>
<tr>
<td>null</td>
<td>false</td>
<td>null</td>
</tr>
<tr>
<td>不是Employee</td>
<td>false</td>
<td>Execption</td>
</tr>
</tbody>
</table>
<p>判断p指向的是一个Employee对象，且不是其子类：</p>
<pre class="hljs"><code><div>if (p.getClass == classOf[Employee])
// classOf方法定义在scala.Predef对象中，自动引入。
</div></code></pre>
<p>更好的方法是使用模式匹配而非类型检查与转换：</p>
<pre class="hljs"><code><div>p match{
    case s: Employee =&gt; ... // 将s作为Employee
    case _ =&gt; //p不是Employee
}
</div></code></pre>
<h3 id="84-%E5%8F%97%E4%BF%9D%E6%8A%A4%E5%AD%97%E6%AE%B5%E5%92%8C%E6%96%B9%E6%B3%95">8.4 受保护字段和方法</h3>
<ol>
<li>protected成员可以被任何子类访问到（同Java）。</li>
<li>protedced成员对类所属的包成员不可见（不同于Java）。</li>
<li>protected[this]可以将访问权限限定在当前的对象。</li>
</ol>
<h3 id="85-%E8%B6%85%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0">8.5 超类的构造</h3>
<p>类中每个辅助构造器都必须以对先前定义的辅助构造器或主构造器的调用开始。这样做就导致：辅助构造器<strong>永远不可能</strong>直接调用超类的构造器。子类的辅助构造器都会直接和间接地调用主构造器，只有主构造器可以调用超类的构造器。Scala的构造器中，不能调用super(param)。</p>
<p>主构造器和类定义结合在一起，子类调用超类构造器的方法也结合在一起，例如：</p>
<pre class="hljs"><code><div>class Employee(name: String, age: Int, val salary: Double) extends Person(name, age)
// 这部分定义了一个子类，以及一个调用超类构造器的主构造器
</div></code></pre>
<p>同样功能的Java代码：</p>
<pre class="hljs"><code><div>public class Employee extends Person {
    private double salary;
    public Employee(String name, int age, double salary){
        super(name,age);
        this.salary = salary;
    }
}
</div></code></pre>
<p>Scala类可以扩展Java类。这种情况下它的主构造器必须调用Java超类的某一个构造方法。如：</p>
<pre class="hljs"><code><div>class Square(x: Int, y: Int, width: Int) extends java.awt.Rectangle(x,y,width,width)
</div></code></pre>
<h3 id="86-%E9%87%8D%E5%86%99%E5%AD%97%E6%AE%B5">8.6 重写字段</h3>
<p>Scala的字段由一个private字段和getter/setter方法构成。可以用另一个同名的val字段重写一个val（或不带参数的def）。子类有一个私有字段和一个公有的getter方法，这个getter方法重写了超类的getter方法。</p>
<table>
<thead>
<tr>
<th>目的</th>
<th>用val</th>
<th>用def</th>
<th>用var</th>
</tr>
</thead>
<tbody>
<tr>
<td>重写val</td>
<td>子类有一个私有字段（与超类的字段名字相同）</td>
<td>错误</td>
<td>错误</td>
</tr>
<tr>
<td>重写def</td>
<td>- 子类有一个私有字段 - getter方法重写超类的方法</td>
<td>和Java一样</td>
<td>var可以重写getter/setter对，但只重写getter会报错。</td>
</tr>
<tr>
<td>重写var</td>
<td>错误</td>
<td>错误</td>
<td>仅当超类的var是抽象时才可以。</td>
</tr>
</tbody>
</table>
<p>从上表中可以看出写var，影响扩展性。</p>
<h3 id="87-%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB">8.7 匿名子类</h3>
<p>可以用包含定义或重写代码块的方式创建一个匿名的子类。</p>
<pre class="hljs"><code><div>val alien = new Person(&quot;Fred&quot;){
    def greeting = &quot;Greetings! My name is Fred.&quot;
}
</div></code></pre>
<p>上述对象将创建一个结构类型的对象，该类型标记为Person{def greeting: String}。可以使用如下类型作为参数类型的定义：</p>
<pre class="hljs"><code><div>def meet(p: Person{def greeting: String}){
    println(p.name + &quot;says: &quot;+p.greeting)
}
</div></code></pre>
<h3 id="88-%E6%8A%BD%E8%B1%A1%E7%B1%BB">8.8 抽象类</h3>
<p>有些类不能实例化，因为某些方法暂不能完整定义，此时用abstract标记。</p>
<pre class="hljs"><code><div>abstratc class Person(val name: String){
    def id: Int //没有方法体--这是一个抽象方法。
}
</div></code></pre>
<ol>
<li>如果某个类存在一个或多个抽象方法，必须将该类声明为abstract。（同Java）</li>
<li>不需要对抽象方法加abstract关键字，省去方法体即可。（不同于Java）</li>
<li>在子类中重写超类的抽象方法是，不需要使用override关键字。</li>
</ol>
<h3 id="89-%E6%8A%BD%E8%B1%A1%E5%AD%97%E6%AE%B5">8.9 抽象字段</h3>
<p>抽象字段就是没有初始值的字段。</p>
<ol>
<li>对于val，默认有抽象的getter方法。</li>
<li>对于var，默认有抽象的getter/setter方法。</li>
<li>生成的Java类不带字段。</li>
</ol>
<p>具体的子类中，必须提供具体的字段。在子类中重写超类中的抽象字段时，不需要override关键字。</p>
<h3 id="89-%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F%E5%92%8C%E6%8F%90%E5%89%8D%E5%AE%9A%E4%B9%89">8.9 构造顺序和提前定义</h3>
<pre class="hljs"><code><div>class Creature{
    val range: Int = 10
    val env: Array[Int] = new Array[Int](range)

}

class Ant extends Creature{
    override val range = 2
}
</div></code></pre>
<p>超类构造器先于子类的构造器运行。上述代码运行时，创建一个Ant对象，将得到长度为0的env,因为输出Ant类的range字段值时会重写Creature中的range字段，所以range方法返回0，env被设为长度为0的数组。
因此：<strong>在构造器中不应该依赖val的值</strong>
被调用的方法可能被子类重写，事实上初始化env的时候调用了range的getter方法。</p>
<p>上述问题有如下解决方式：</p>
<ul>
<li>将val声明为final，安全但不灵活。</li>
<li>在超类中将val声明为lazy，安全但不高效。</li>
<li>在子类中使用提前定义语法。</li>
</ul>
<p>&quot;提前定义&quot;语法使用<strong>with</strong>关键词可以在超类的构造器执行之前初始化子类的val字段。如：</p>
<pre class="hljs"><code><div>class Ant extends{
    override val range = 2
} with Creature
// 提前定义的等号右侧只能引用之前已有的定义，不能使用类中的其他字段或方法。
</div></code></pre>
<h3 id="811-scala%E7%BB%A7%E6%89%BF%E5%B1%82%E7%BA%A7">8.11 Scala继承层级</h3>
<p>暂略。</p>
<h3 id="812-%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E6%80%A7">8.12 对象相等性</h3>
<p>AnyRef下的eq方法检查两个引用是否指向同一个对象。实现一个类时，应该考虑重写该类的equals方法，以提供与实际情况相称的相等性判断。</p>
<p>为了保证相等判断的对称性，将方法定义在父类中，并且标记为final。</p>
<p>定义equals时，同时也定义hashCode。</p>
<p>在应用程序中，通常使用==操作符即可，不需直接调用eq或equals，对于引用类型而言，在做完必要的null检查后，会调用equals方法。</p>
<h2 id="%E7%AC%AC9%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">第9章 文件和正则表达式</h2>
<p>要点：</p>
<ol>
<li>Source.fromFile(...).getLines.toArray 输出文件的所有行。</li>
<li>Source.fromeFile(...).mkString 以字符串形式输出文件内容。</li>
<li>str.toInt, str.toDouble</li>
<li>PrintWrinter</li>
</ol>
<h2 id="%E7%AC%AC10%E7%AB%A0-%E7%89%B9%E8%B4%A8-%EF%BC%88trait%EF%BC%89">第10章 特质 （Trait）</h2>
<p>要点：</p>
<ol>
<li>类可以实现任意数量的trait。</li>
<li>trait可以要求实现它们的类具备特定的字段、方法或超类。</li>
<li>Scala的trait可以提供方法和字段的实现。（不同于Java接口）</li>
<li>多个trait叠加在一起时应该注意顺序，其方法先被执行的trait排在后面。</li>
</ol>
<h3 id="101-%E6%B2%A1%E6%9C%89%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF">10.1 没有多重继承</h3>
<p>多重继承代价较高，可能需要解决方法冲突等问。因此Scala和Java一样不支持多重继承。</p>
<p>trait可以同时拥有抽象方法和具体方法，类可以实现多个特质。</p>
<h3 id="102-%E5%BD%93%E4%BD%9Cinterface%E4%BD%BF%E7%94%A8%E7%9A%84trait">10.2 当作interface使用的trait</h3>
<p>特质中未被实现的方法默认是抽象的，无需声明为abstract。</p>
<pre class="hljs"><code><div>trait Loggeer{
    def log(msg: String)
}

class ConsoleLogger extends Logger { //用extends而不是implements
    def log(msg: String){ //重写trait的抽象方法时，不需要使用override关键字
        println(msg)
    }
}
</div></code></pre>
<p>如果需要多个trait，可以用with关键字添加额外的trait：
<code>class ConsoleLogger extends Logger with Cloneable with Serializable</code></p>
<h3 id="103-%E5%B8%A6%E6%9C%89%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%9A%84trait">10.3 带有具体实现的trait</h3>
<p>trait中的方法不一定是抽象的，可以做具体实现。</p>
<p>如下代码声明并使用一个特质：</p>
<pre class="hljs"><code><div>trait ConsoleLogger{
    def log(msg: String) { printl(msg)}
}

class SavingsAccount extends Account with ConsoleLogger {
    def withdraw(amount: Double){
        if(amount &gt; balace) log(&quot;Insufficient funds&quot;)
    }
}
</div></code></pre>
<h3 id="104-%E5%B8%A6%E6%9C%89trait%E7%9A%84%E5%AF%B9%E8%B1%A1">10.4 带有trait的对象</h3>
<pre class="hljs"><code><div>trait Logged {
    def log(msg: String){ }
}

class SavingAccount extends Account with Logged {
    def withdraw(amount: Double){
        if(amount: Double){
            if(amount &gt; balance) log(&quot;Insufficient funds&quot;)
            else ...
        }
        ...
    }
}

trait ConsoleLogger extends Logged {
    override def log(msg: String){  println(msg)    }
}

//在构造不同对象的时候加入不同的trait
val acct = new SavingAccount with ConsoleLogger

val acct2 = new SavingsAccount with FileLogger

</div></code></pre>
<h3 id="105-%E5%8F%A0%E5%8A%A0%E5%9C%A8%E4%B8%80%E8%B5%B7%E7%9A%84trait">10.5 叠加在一起的trait</h3>
<p>类或对象可以添加多个互相调用的trait，其调用顺序从最后一个开始。</p>
<h3 id="106-%E5%9C%A8trait%E4%B8%AD%E9%87%8D%E5%86%99%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95">10.6 在trait中重写抽象方法</h3>
<h3 id="107-%E5%BD%93%E4%BD%9C%E5%AF%8C%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8%E7%9A%84trait">10.7 当作富接口使用的trait</h3>
<h2 id="%E7%AC%AC11%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6">第11章 操作符</h2>
<p>要点：</p>
<ol>
<li>一元和二元操作符实际上是方法调用。</li>
<li>操作符优先级取决于第一个字符，而结合性取决于最后一个字符。</li>
<li>提取器从输入中提取元组或值的序列。</li>
</ol>
<h3 id="111-%E6%A0%87%E8%AF%86%E7%AC%A6">11.1 标识符</h3>
<p>包括变量、函数、类的名称。</p>
<p>Scala在选择标识符时比Java有更多选择，但最好还是传统一点（个人喜好）。</p>
<p>设计标识符时要尽量易读，易于输入。</p>
<h3 id="112-%E4%B8%AD%E7%BD%AE%E6%93%8D%E4%BD%9C%E7%AC%A6">11.2 中置操作符</h3>
<p><code>a 标识符 b</code></p>
<p>实际上是一个方法调用 ：</p>
<pre class="hljs"><code><div>1 to 10
1.to(10)
</div></code></pre>
<h3 id="113-%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6">11.3 一元操作符</h3>
<p><code>a 标识符</code>等同于a.标识符()，如：</p>
<pre class="hljs"><code><div>a toString
1.toString()
</div></code></pre>
<p><code>+</code>,<code>-</code>,<code>!</code>,<code>~</code>可以作为前置操作符出现在参数之前。</p>
<h3 id="114-%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6">11.4 赋值操作符</h3>
<pre class="hljs"><code><div>a 操作符= b
a = a 操作符 b

a += b
a = a + b
</div></code></pre>
<h3 id="115-%E4%BC%98%E5%85%88%E7%BA%A7">11.5 优先级</h3>
<p>后置操作符的优先级低于中置操作符。</p>
<h3 id="116-%E7%BB%93%E5%90%88%E6%80%A7">11.6 结合性</h3>
<h2 id="%E7%AC%AC13%E7%AB%A0-%E9%9B%86%E5%90%88">第13章 集合</h2>
<ul>
<li>所以集合都扩展自Iterable特质。</li>
<li>集合有三大类，分别是序列、集和映射。</li>
<li>对于几乎所有集合类，都提供了可变和不可变的版本。</li>
<li>Scala列表要么是空的，要么拥有一头一尾，其中尾部本身又是一个列表。</li>
<li>集是无先后次序的集合。</li>
<li>用LinkedHashSet来保留插入顺序，或者用SortedSet来按顺序进行迭代。</li>
<li>+将元素添加到无先后次序的集合中，+:和:+向前或向后追加到序列；++将两个集合串接在一起；-和--移除元素。</li>
</ul>
<h3 id="131-%E4%B8%BB%E8%A6%81%E7%9A%84%E9%9B%86%E5%90%88%E7%89%B9%E8%B4%A8">13.1 主要的集合特质</h3>
<p>Seq有先后次序，如数组或列表。</p>
<p>Set是没有先后次序的，在SortedSet中，元素以某种排过序的顺序被访问。</p>
<p>Map是一组（键，值）对偶。</p>
<h3 id="132-%E5%8F%AF%E5%8F%98%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88">13.2 可变和不可变集合</h3>
<ul>
<li><strong>可变</strong>：scala.collection.mutable._</li>
<li><strong>不可变</strong>： scala.collection.immutable._
同时继承自scala.collection._</li>
</ul>
<h3 id="133-%E5%BA%8F%E5%88%97">13.3 序列</h3>
<h5 id="%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BA%8F%E5%88%97">不可变序列</h5>
<ul>
<li>Vector</li>
<li>Range</li>
<li>List</li>
<li>Stream</li>
<li>Stack</li>
<li>Queue</li>
</ul>
<h5 id="%E5%8F%AF%E5%8F%98%E5%BA%8F%E5%88%97%EF%BC%9A">可变序列：</h5>
<ul>
<li>ArrayBuffer</li>
<li>Stack</li>
<li>Queue</li>
<li>Priority Queue</li>
<li>LinkedList</li>
<li>Double LinkedList</li>
</ul>
<p>Vector是ArrayBuffer的不可变版本：一个带下标的序列，支持快速随机访问。Vector是以树形结构实现的。</p>
<p>Range表示整数序列，只存储起始值、结束值和增值，可以用to和until方法构造Range对象。</p>
<h3 id="134-%E5%88%97%E8%A1%A8">13.4 列表</h3>
<p>在Scala中，列表要么是Nil，要么是一个head加上一个tail，而tail又是一个列表。
如：</p>
<pre class="hljs"><code><div>val digits = List(4,2) 
//digits.head = 4
//digits.tail = List(2)
//digits.tail.tail = Nil
</div></code></pre>
<p><code>::</code>操作符放在头部或尾部可以得到新的列表。并且遍历列表使用递归方法会非常自然，如：</p>
<pre class="hljs"><code><div>9::List(4,2)

def sum(lst: List[Int]): Int = {
    if(lst == Nil) 0 else lst.head + sum(lst.tail)
}
</div></code></pre>
<h3 id="135-%E5%8F%AF%E5%8F%98%E5%88%97%E8%A1%A8">13.5 可变列表</h3>
<pre class="hljs"><code><div>// set negative to 0
val lst = scala.collection.mutable.LinkedList(1, -2, 7, -9)
var cur = lst
while(cur != Nil) {
    if(cur.elem &lt; 0 cur.elem = 0)
    cur = cur.next
}

// 隔一个删除
var cur = lst
while(cur != Nil &amp;&amp; cur.next != Nil) {
    cur.next = cur.next.next
    cur = cur.next
}
</div></code></pre>
<p>Tips: 如果想把列表中的某个节点变为列表的最后一个节点，不能将next引用设为Nil或null，应该设为<strong>LinkedList.empty</strong>。</p>
<h3 id="136-set">13.6 Set</h3>
<p>缺省情况下，Set是以哈希集实现的，其元素根据hashCode方法的值进行组织。Set不保持元素的顺序，因为在哈希集中查找元素比在数组和列表中快得多。</p>
<p>LinkedHashSet可以记住元素插入的顺序，它会维护一个链表来实现。
如果想按照已排序的顺序来访问集合中的元素，可以用SortedSet，它是用红黑树实现的:</p>
<pre class="hljs"><code><div>val weekdays = scala.collection,mutable,LinkedHashSet(&quot;Mo&quot;,&quot;Tu&quot;,&quot;We&quot;,&quot;Th&quot;,&quot;Fr&quot;)
val scala.collection.immutable.SortedSet(1, 2, 3, 4, 5, 6)
</div></code></pre>
<p>一些常见的集合操作：<code>union</code>、<code>intersect</code>、<code>diff</code>
一般而言，<code>+</code>用于将元素添加到无先后次序的集合，而<code>+:</code>和<code>:+</code>将元素添加到有先后次序的集合的开头或末尾。</p>
<h3 id="137-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%9A">13.7 常用操作符：</h3>
<table>
<thead>
<tr>
<th>operator</th>
<th>description</th>
<th>Collection Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>coll :+ elem</td>
<td>追加</td>
<td>Seq</td>
</tr>
<tr>
<td>coll + elem</td>
<td>添加</td>
<td>Set、Map</td>
</tr>
<tr>
<td>coll - elem</td>
<td></td>
<td>Set、Map、ArrayBuffer</td>
</tr>
<tr>
<td>coll ++ coll2</td>
<td>与coll同类型的集合，包含两个集合的元素</td>
<td>Iterable</td>
</tr>
<tr>
<td>coll -- coll2</td>
<td></td>
<td>Set、Map、ArrayBuffer</td>
</tr>
<tr>
<td>elem::lst</td>
<td>被向前追加了元素或给定列表的列表</td>
<td>List</td>
</tr>
<tr>
<td>list ::: list2</td>
<td>等同于list ++： list2</td>
<td>List</td>
</tr>
<tr>
<td>set | set2  set &amp; set2 set &amp;~ set2</td>
<td>两个集合的并、交、差</td>
<td>Set</td>
</tr>
<tr>
<td>coll += elem  coll += (e1,e2,...) coll ++= coll2(<code>+</code>可以换成<code>-</code>)</td>
<td>添加或移除指定元素</td>
<td>可变集合</td>
</tr>
<tr>
<td>elem +=: coll coll2 ++=: coll</td>
<td>向前追加给定元素或集合修改coll</td>
<td>ArrayBuffer</td>
</tr>
</tbody>
</table>
<p>一般而言，<code>+</code>用于将元素添加到无先后次序的集合，而<code>+:</code>和<code>:+</code>分别将元素添加到有先后次序的集合的开头或末尾。</p>
<p><strong>右结合</strong>的操作符都返回新的集合，不会修改原有的集合，而可变集使用的是左结合的操作元。</p>
<h3 id="138-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">13.8 常用方法</h3>
<h5 id="%E8%A1%A813-2-iterable%E7%89%B9%E8%B4%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">表13-2 Iterable特质的常用方法</h5>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>head, last, headOption, lastOption</td>
<td>返回第一个或最后一个元素，或用Option形式返回</td>
</tr>
<tr>
<td>tail, init</td>
<td>返回除第一个或最后一个元素以外的部分</td>
</tr>
<tr>
<td>length, isEmpty</td>
<td>略</td>
</tr>
<tr>
<td>map(f), foreach(f), flatMap(f), collect(pf)</td>
<td>将函数应用到所有元素</td>
</tr>
<tr>
<td>reduceLeft(op), reduceRight(op), foldLeft(init)(op), foldRight(init)(op)</td>
<td>以给定顺序将二元操作应用到所有元素</td>
</tr>
<tr>
<td>reduce(op), fold(init)(op), aggregate(init)(op,combineOp)</td>
<td>以非特定顺序将二元操作符应用到所有元素</td>
</tr>
<tr>
<td>sum, product, max, min</td>
<td>返回该值（前提是可以隐式转换）</td>
</tr>
<tr>
<td>count(pred), forall(pred), exists(pred)</td>
<td>返回满足前提表达式的元素计数； Boolean值； Boolean值；</td>
</tr>
<tr>
<td>filter(pred), filterNot(pred), partition(pred)</td>
<td>返回所有满足前提表达式的元素；所有不满足前提表达式的元素； 这两组元素组成的对偶；</td>
</tr>
<tr>
<td>takeWhile(pred), dropWhile(pred), span(pred)</td>
<td>返回满足前提表达式的一组元素（直到遇见第一个不满足的元素）；所有其他元素；或者这两组元素组成的对偶。</td>
</tr>
<tr>
<td>take(n), drop(n), splitAt(n)</td>
<td>返回前n个元素； 所有其他元素；这两组元素组成的对偶。</td>
</tr>
<tr>
<td>takeRight(n), dropRight(n)</td>
<td>返回最后n个元素；或者其他所有元素。</td>
</tr>
<tr>
<td>slice(from, to)</td>
<td>返回从from到to区间内的所有元素。</td>
</tr>
<tr>
<td>zip(coll2)、zipAll(coll2, fill, fill2)、 zipWityIndex</td>
<td>返回由本集合的元素和另一个集合的元素组成的对偶。</td>
</tr>
<tr>
<td>grouped(n)、sliding(n)</td>
<td>返回长度为n的子集合迭代器；grouped产出下标为0 until n 的元素，然后是下标为n until 2*n的元素，以此类推；sliding产出下标为0 until n的元素，然后是下标为1 until n+1 的元素，以此类推。</td>
</tr>
<tr>
<td>mkString(before, between, after)、addString(sb, before, between, after)</td>
<td>由所有元素组成的字符串，将给定字符串分别添加到首个元素之前、每个元素之间，以及最后一个元素之后。第二个方法将字符串追加到stringbuilder当中</td>
</tr>
<tr>
<td>toIterable, toSeq, toIndexedSeq, toArray, toList, toStream, toSet, toMap</td>
<td>将集合转换成指定类型的集合</td>
</tr>
<tr>
<td>copyToArray(arr), copyToArray(arr, start, length), copyToBuffer(buf)</td>
<td>将元素拷贝到数组或缓冲当中</td>
</tr>
</tbody>
</table>
<h5 id="seq%E5%9C%A8iterable%E5%9F%BA%E7%A1%80%E4%B8%8A%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%96%B9%E6%B3%95">Seq在Iterable基础上添加的方法</h5>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>contains(elem), containsSlice(seq), startsWith(seq), endsWith(seq)</td>
<td>返回布尔值</td>
</tr>
<tr>
<td>indexOf(elem), lastIndexOf(elem), indexOfSlice(seq), lastIndexOfSlice(seq)</td>
<td>返回对应下标</td>
</tr>
<tr>
<td>indexWhere(pred)</td>
<td>返回满足pred的首个元素的下标</td>
</tr>
<tr>
<td>prefixLength(pred), segmentLength(pred,n)</td>
<td>返回满足pred的最长元素序列的长度，从当前序列的下标0或n开始查找</td>
</tr>
<tr>
<td>padTo(n, fill)</td>
<td>返回当前序列的一个拷贝，将fill的内容向后追加，知道新序列的长度达到n</td>
</tr>
<tr>
<td>intersect(seq), diff(seq)</td>
<td>返回多重集合的交集，或序列之间的差异</td>
</tr>
<tr>
<td>reverse</td>
<td>当前序列的反向</td>
</tr>
</tbody>
</table>
<p>sorted, sortWith(less), sortBy(f) 使用元素本身的大小，二元函数less，或者将每个元素映射成一个带先后次序的类型的值的函数f，对当前序列进行排序后的新序列。
permutations, combinations(n) | 返回一个遍历所有排列或组合的迭代器</p>
<p>这些方法都不改变原有集合，返回一个与原集合类型相同的新集合。</p>
<h3 id="139-%E5%B0%86%E5%87%BD%E6%95%B0%E6%98%A0%E5%B0%84%E5%88%B0%E9%9B%86%E5%90%88">13.9 将函数映射到集合</h3>
<p><code>map</code>,<code>flatMap</code></p>
<pre class="hljs"><code><div>names.map(_.toUpperCase)
names,flatMap(ulcase)
如果使用flatMap并传入返回Option的函数的话，最终返回的集合将包括所有的值v，前提是函数返回Some(v)
</div></code></pre>
<p><code>collect</code>方法用于oartial function --- 那些并没有对所有可能的输入进行定义的函数，他产出被定义的所有参数的函数值的集合。</p>
<h3 id="1310-%E5%8C%96%E7%AE%80%E3%80%81%E6%8A%98%E5%8F%A0%E5%92%8C%E6%89%AB%E6%8F%8F">13.10 化简、折叠和扫描</h3>
<pre class="hljs"><code><div>c.reduceLeft(op)
c.reduceRight(op)
c.foldLeft(init)(op)
scanLeft
scanRight
</div></code></pre>
<h3 id="1311-%E6%8B%89%E9%93%BE%E6%93%8D%E4%BD%9C">13.11 拉链操作</h3>
<pre class="hljs"><code><div>val prices = List(5.0, 20.0, 9.95)
val quantities = List(10, 2, 1)
prices zip quantities
得到：
List[(Double, Int)] = List((5.0, 10), (20.0, 2), (9.95, 1))

// 其他用法：
(prices zip quantities) map {p =&gt; p._1 * p._2}
((prices zip quatities) map {p =&gt; p._1 * p._2}).sum
//如果一个集合比另一个短，那么集合中的对偶数量与较短的集合中元素数量相同。
//zipAll方法可以指定较短列表中的缺省值。
List((5.0, 20.0, 9.95).zipAll(List(10,2), 0.0, 1)
//将得到：
List((5.0, 10), (20.0, 2), (9.95, 1))
zipWithIndex 方法返回对偶的列表，每个对偶中第二个组成部分是每个元素的下标。
</div></code></pre>
<h3 id="1312-%E8%BF%AD%E4%BB%A3%E5%99%A8">13.12 迭代器</h3>
<p>Scala并不提倡使用迭代器，通过前两节的方法可以更容易地获取结果。（是否便于Spark化？）</p>
<h3 id="1313-%E6%B5%81">13.13 流</h3>
<p>流是一个尾部被懒计算的不可变列表，只有需要时才会被计算。和迭代器一样，只有在需要的时候才去取元素，不会付出计算剩余元素的代价。</p>
<pre class="hljs"><code><div>def numsFrom(n: BigInt): Stream[BigInt] = n #:: numsFrom(n + 1)
</div></code></pre>
<p><code>#::</code>操作符很像是列表的<code>::</code>操作符，不过它构建出的是一个流。</p>
<p>当调用 val tenOrMore = numsFrom(10)时，得到的是一个被显示为Stream(10, ?) 的流对象。其尾部未被求值。</p>
<h3 id="1314-%E6%87%92%E8%A7%86%E5%9B%BE">13.14 懒视图</h3>
<p>略</p>
<h3 id="1315-%E4%B8%8Ejava%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C">13.15 与Java集合的互操作</h3>
<pre class="hljs"><code><div>import scala.collection.JavaConversions._
val props: scala.collection.mutable.Map[String, String] = System.getProperties()
</div></code></pre>
<h3 id="1316-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88">13.16 线程安全的集合</h3>
<p><code>SynchronizedBuffer</code>,<code>SynchronizedMap</code>,<code>SynchronizedPriorityQueue</code>,<code>SynchronizedSet</code>,<code>SynchronizedStack</code></p>
<p>通常说来，如果想保证线程安全，可以用java.util.concurrent包中的某个类。比如，多个线程共享一个Map, 就用<code>ConcurrentHashMap</code>或<code>ConcurrentSkipListMap</code>这比用同步方式执行所有方法的映射更为高效。</p>
<h3 id="1317-%E5%B9%B6%E8%A1%8C%E9%9B%86%E5%90%88">13.17 并行集合</h3>
<p>Scala为并行提供了很多方便，比如对一个大型集合coll求和，只需要<code>coll.par.sum</code>即可。</p>
<p>并不是所有的方法都可以并行化。</p>
<h2 id="%E7%AC%AC14%E7%AB%A0-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%92%8C%E6%A0%B7%E4%BE%8B%E7%B1%BB">第14章 模式匹配和样例类</h2>
<p>本章要点：</p>
<ul>
<li>match表达式不会意外掉入下一个分支。</li>
<li>如果没有成功匹配，会抛出MatchError，可以用case_避免。</li>
<li>模式可以包含一个随意定义的条件，称作守卫。</li>
<li>可以对表达式的类型进行匹配，而且应该优先选择模式匹配而不是isInstanceOf/asInstanceOf。</li>
<li>可以匹配数组、元组和样例类的模式，然后将匹配到的不同部分绑定到变量。</li>
<li><strong>在for表达式中，不能匹配的情况会被安静地跳过。</strong></li>
<li>样例类是编译器会为之自动产出模式匹配所需要的方法的类。</li>
<li>样例类继承层级中的公共超类应该是sealed的。</li>
<li>用Option来存放那些不确定是否存在的值，这会比null更安全。</li>
</ul>
<h3 id="141-match">14.1 match</h3>
<p>在类C语言中，必须在每个分支的末尾显式地使用break语句来退出switch，否则将掉入下一分支。</p>
<pre class="hljs"><code><div>sign = ch match {
    case '+' =&gt; 1
    case '-' =&gt; -1
    case _ =&gt; 0
}
</div></code></pre>
<h3 id="142-%E5%AE%88%E5%8D%AB">14.2 守卫</h3>
<p>Scala的模式中可以包括随意定义的条件,这叫做守卫，守卫可以是任何Boolean条件：</p>
<pre class="hljs"><code><div>ch match{
    case '+' =&gt; sign = 1
    case _ if Character.isDigit(ch) -&gt; digit = Character.digit(ch, 10) 
}
</div></code></pre>
<h3 id="143-%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F">14.3 模式中的变量</h3>
<p>如果case关键字后边跟着一个变量名，那么匹配的表达式会被赋给那个变量：</p>
<pre class="hljs"><code><div>str(i) match {
    case ch =&gt; digit = Character.digit(ch, 10)
}
</div></code></pre>
<p>另，scala中变量必须以小写字母开头，如果某个变量以小写字母开头，则应该将它包在反括号里，如： `pi`</p>
<h3 id="144-%E7%B1%BB%E5%9E%8B%E6%A8%A1%E5%BC%8F">14.4 类型模式</h3>
<p>可以用于替代isInstanceOf:</p>
<pre class="hljs"><code><div>obj match {
    case x: Int =&gt; x
    case s: String =&gt; Integer.parseInt(s)
    case _: BigInt =&gt; Int.MaxValue
    case + =&gt; 0
}
</div></code></pre>
<p>当匹配类型的时候必须给出变量名，否则将会用对象本身去匹配。</p>
<h3 id="145-%E5%8C%B9%E9%85%8D%E6%95%B0%E7%BB%84%E3%80%81%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84">14.5 匹配数组、列表和元组</h3>
<p>要匹配数组的内容，可以在模式中使用Array表达式，List和元组同理。</p>
<pre class="hljs"><code><div>arr match {
    //匹配包含0的数组
    case Array(0) =&gt; &quot;0&quot;

    //匹配带有两个元素的数组
    case Array(x, y) =&gt; x + &quot; &quot; + y
    
    //匹配任何以0开始的数组
    case Array(0, _*) =&gt; &quot;0 ...&quot;
    case + =&gt; &quot;something else&quot;
}

lst match {
    case 0 :: Nil =&gt; &quot;0&quot;
    case x :: y :: Nil =&gt; x + &quot; &quot; + y
    case 0 :: tail =&gt; &quot;0 ...&quot;
    case _ =&gt; &quot;something else&quot;
}

pair match {
    case (0, _) =&gt; &quot;0 ...&quot;
    case (y, 0 ) =&gt; y + &quot; 0&quot;
    case _ =&gt; &quot;neither is 0&quot;
}
</div></code></pre>
<h3 id="146-%E6%8F%90%E5%8F%96%E5%99%A8">14.6 提取器</h3>

</body>
</html>

# OOP设计模式
## 0. 综述

这篇文章随着我不断学习设计模式会不断更新，不断加入新的收获和感受。设计模式如练功口诀，背熟了没什么用，重要的是把心法活用，勤学多练。


设计模式：在某些场景下，针对某类问题的某种通用的解决方案。


创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。

结构型模式：把类或对象结合在一起形成一个更大的结构。

行为型模式：类和对象如何交互，及划分责任和算法。

#### 23种设计模式：
1. 单例模式：某个类只能有一个实例，提供一个全局的访问点。

2. 简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。

3. 工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。

4. 抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。

5. 建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。

6. 原型模式：通过复制现有的实例来创建新的实例。

7. 适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。

8. 组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。

9. 装饰模式：动态的给对象添加新的功能。

10. 代理模式：为其他对象提供一个代理以便控制这个对象的访问。

11. 亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。

12. 外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。

13. 桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。

14. 模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。

15. 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。

16. 策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。

17. 状态模式：允许一个对象在其对象内部状态改变时改变它的行为。

18. 观察者模式：对象间的一对多的依赖关系。

19. 备忘录模式：在不破坏封装的前提下，保持对象的内部状态。

20. 中介者模式：用一个中介对象来封装一系列的对象交互。

21. 命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。

22. 访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。

23. 责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。

24. 迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。

## 1. 单例模式
确保某一个类只有一个实例，并且提供一个全局访问点。
#### 特点：
1. 只有一个实例。 
2. 自我实例化。
3. 提供全局访问点。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612001.png)

## 2. 工厂方法模式
工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，让实例化推迟到子类。

虽然他很好的符合了“开闭原则”，但是由于每新增一个新产品时就需要增加两个类，这样势必会导致系统的复杂度增加。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612002.png)

## 3. 抽象工厂模式
提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612003.png)

## 4. 建造者模式
将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。适用于那些产品对象的内部结构比较复杂的情况。
建造者模式将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。但是如果某个产品的内部结构过于复杂，将会导致整个系统变得非常庞大，不利于控制，同时若几个产品之间存在较大的差异，则不适用建造者模式。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612004.png)

## 5. 原型模式
原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。
原型模式包含如下角色：
- Prototype：抽象原型类
- ConcretePrototype：具体原型类
- Client：客户类

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612005.png)

## 6. 适配器模式

在应用程序中需要将两个不同接口的类来进行通信，在不修改这两个类的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。它可以让原本两个不兼容的接口能够无缝完成对接。

作为中间件的适配器将目标类和适配者解耦，增加了类的透明性和可复用性。

适配器模式包含如下角色：
- Target：目标抽象类
- Adapter：适配器类
- Adaptee：适配者类
- Client：客户类

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612006.png)

## 7. 桥接模式
桥接模式就是将抽象部分和实现部分隔离开来，使得他们能够独立变化。桥接模式将继承关系转化成关联关系，封装了变化，完成了解耦，减少了系统中类的数量，也减少了代码量。

桥接模式包含如下角色：
- Abstraction：抽象类
- RefinedAbstraction：扩充抽象类
- Implementor：实现类接口
- ConcreteImplementor：具体实现类

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612007.png)
## 8. 组合模式
组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。它定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理。在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。
组合模式能够清晰地定义分层次的复杂对象，也使得增加新构件也更容易，但是这样就导致了系统的设计变得更加抽象。

组合模式包含如下角色：
- Component: 抽象构件
- Leaf: 叶子构件
- Composite: 容器构件
- Client: 客户类

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612008.png)

## 9. 装饰模式
可以通过继承和组合的方式来给一个对象添加行为，虽然使用继承能够很好拥有父类的行为，但存在如下缺陷：
1. 若对象之间的关系复杂，系统变得复杂不利于维护。
2. 容易产生“类爆炸”现象。
3. 静态。

装饰者模式，动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案。虽然装饰者模式能够动态将责任附加到对象上，但是他会产生许多的细小对象，增加了系统的复杂度。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612009.png)

装饰模式包含如下角色：
- Component: 抽象构件
- ConcreteComponent: 具体构件
- Decorator: 抽象装饰类
- ConcreteDecorator: 具体装饰类

## 10. 外观模式
类与类之间的耦合性越低，可复用性就越好，如果两个类不必彼此通信，就不要让两个类发生直接的相互关系，如果需要调用其中的方法，可以通过第三者转发调用。
外观模式提供了一个统一的接口，用来访问子系统中的一群接口。它让一个应用程序中子系统间的相互依赖关系减少到了最少，它给子系统提供了一个简单、单一的屏障，客户通过这个屏障来与子系统进行通信。但是它违背了“开闭原则”，因为增加新的子系统可能需要修改外观类或客户端的源代码。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612010.png)

外观模式包含如下角色：
- Facade: 外观角色
- SubSystem:子系统角色

## 11. 亨元模式
系统中大量重复的对象可能会占用很多资源。享元模式对对象的重用提供了一种解决方案，它使用共享技术对相同或者相似对象实现重用。享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。享元模式要求能够共享的对象必须是**细粒度对象**。享元模式通过共享技术使得系统中的对象个数大大减少了，同时享元模式使用了内部状态和外部状态，同时外部状态相对独立，不会影响到内部状态，所以享元模式能够使得享元对象在不同的环境下被共享。同时正是分为了内部状态和外部状态，享元模式会使得系统变得更加复杂，同时也会导致读取外部状态所消耗的时间过长。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612011.png)

享元模式包含如下角色：
- Flyweight: 抽象享元类
- ConcreteFlyweight: 具体享元类
- UnsharedConcreteFlyweight: 非共享具体享元类
- FlyweightFactory: 享元工厂类

## 12. 代理模式
代理模式就是给对象提供代理，并由代理对象控制对原对象的引用。它使得客户不能直接与真正的目标对象通信。代理对象是目标对象的代表，其他需要与这个目标对象打交道的操作都是和这个代理对象在交涉。代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的，同时也在一定程度上面减少了系统的耦合度。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612012.png)

## 13. 访问者模式
软件开发中可能会对同一个对象有不同的处理，如果都做分别的处理，将会产生灾难性的错误。对于这种问题，访问者模式提供了比较好的解决方案。访问者模式即表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式。
同时还需要明确一点就是访问者模式是适用于那些**数据结构比较稳定**的，因为他是将数据的操作与数据结构进行分离了，如果某个系统的数据结构相对稳定，但是操作算法易于变化的话，就比较适用适用访问者模式，因为访问者模式使得算法操作的增加变得比较简单了。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612013.png)

访问者模式包含如下角色：
- Vistor: 抽象访问者
- ConcreteVisitor: 具体访问者
- Element: 抽象元素
- ConcreteElement: 具体元素 
- ObjectStructure: 对象结构

## 14. 模板模式
所谓模板方法模式就是在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

模板方法模式就是基于继承的代码复用技术的。在模板方法模式中，我们可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中。也就是说我们需要声明一个抽象的父类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法让子类来实现剩余的逻辑，不同的子类可以以不同的方式来实现这些逻辑。所以模板方法的模板其实就是一个普通的方法，只不过这个方法是将算法实现的步骤封装起来的。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612014.png)

模板方法模式包含如下角色：
- AbstractClass: 抽象类
- ConcreteClass: 具体子类

## 15. 策略模式
有很多种方法来实现一个功能，但是我们需要一种简单、高效的方式来实现它，使得系统能够非常灵活，这就是策略模式。

所以策略模式就是定义了算法族，分别封装起来，让他们之间可以互相转换，此模式然该算法的变化独立于使用算法的客户。

在策略模式中，这些解决问题的方法被定义成一个算法群，每一个方法都对应着一个具体的算法，这里的一个算法就称之为一个策略。虽然策略模式定义了算法，但是它并不提供算法的选择，即什么算法对于什么问题最合适这是策略模式所不关心的，所以对于策略的选择还是要客户端来做。**客户必须要清楚的知道每个算法之间的区别和在什么时候什么地方使用什么策略是最合适的，这样就增加客户端的负担。**

同时策略模式也非常完美的符合了“开闭原则”，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。但是一个策略对应一个类将会使系统产生很多的策略类。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612015.png)

策略模式包含如下角色：
- Context: 环境类
- Strategy: 抽象策略类
- ConcreteStrategy: 具体策略类

## 16. 状态模式
很多时候对象的行为依赖于它的一个或一些变化的属性，这些可变的属性被称之为状态。行为依赖状态，即当该对象因为在外部的互动而导致状态发生变化，从而它的行为也会做出相应的变化。对于这种情况，不能用行为来控制状态的变化，而应该站在状态的角度来思考行为，即是什么状态就要做出什么样的行为。这个就是状态模式。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612016.png)

状态模式包含如下角色：
- Context: 环境类
- State: 抽象状态类
- ConcreteState: 具体状态类

## 17. 观察者模式
观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。

发生改变的对象称之为观察目标，而被通知的对象称之为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，所以可以根据需要增加和删除观察者，使得系统更易于扩展。观察者提供了一种对象设计，让主题和观察者之间以松耦合的方式结合。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612017.png)

观察者模式包含如下角色：
- Subject: 目标
- ConcreteSubject: 具体目标
- Observer: 观察者
- ConcreteObserver: 具体观察者

## 18. 备忘录模式
可以使系统恢复到某一特定的历史状态。

所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它实现了对信息的封装，使得客户不需要关心状态保存的细节。保存就要消耗资源，所以备忘录模式的缺点就在于消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612018.png)

备忘录模式包含如下角色：
- Originator: 原发器
- Memento: 备忘录
- Caretaker: 负责人

## 19. 中介者模式

中介者模式就是用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。在中介者模式中，中介对象用来封装对象之间的关系，各个对象可以不需要知道具体的信息通过中介者对象就可以实现相互通信。它减少了对象之间的互相关系，提供了系统可复用性，简化了系统的结构。

 在中介者模式中，各个对象不需要互相知道了解，他们只需要知道中介者对象即可，但是中介者对象就必须要知道所有的对象和他们之间的关联关系，正是因为这样就导致了中介者对象的结构过于复杂，承担了过多的职责，同时它也是整个系统的核心所在，它有问题将会导致整个系统的问题。系统的设计过程中如果出现“多对多”的复杂关系群时，需谨慎思考系统的设计是不是出了问题。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612019.png)

中介者模式包含如下角色：
- Mediator: 抽象中介者
- ConcreteMediator: 具体中介者
- Colleague: 抽象同事类
- ConcreteColleague: 具体同事类

## 20. 迭代器模式
迭代器模式就是提供一种方法顺序访问一个聚合对象中的各个元素，而不是暴露其内部的表示。迭代器模式是将迭代元素的责任交给迭代器，而不是聚合对象，我们甚至在不需要知道该聚合对象的内部结构就可以实现该聚合对象的迭代。

通过迭代器模式，使得聚合对象的结构更加简单，它不需要关注它元素的遍历，只需要专注它应该专注的事情，这样就更加符合单一职责原则了。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612020.png)

迭代器模式包含如下角色：
- Iterator: 抽象迭代器
- ConcreteIterator: 具体迭代器
- Aggregate: 抽象聚合类
- ConcreteAggregate: 具体聚合类

## 21. 解释器模式
解释器模式就是定义语言的文法，并且建立一个解释器来解释该语言中的句子。解释器模式描述了如何构成一个简单的语言解释器，主要应用在使用面向对象语言开发的编译器中。它描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612021.png)

解释器模式包含如下角色：
- AbstractExpression: 抽象表达式
- TerminalExpression: 终结符表达式
- NonterminalExpression: 非终结符表达式
- Context: 环境类
- Client: 客户类

## 22. 命令模式
有时候我们像某个对象发送一个请求，但是并不知道该请求的具体接收者是谁，具体的处理过程是如何的，只知道在程序运行中指定具体的请求接收者即可，对于这样将请求封装成对象的我们称之为命令模式。

命令模式将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。同时命令模式支持可撤销的操作。

命令模式可以将请求的发送者和接收者之间实现完全的解耦，发送者和接收者之间没有直接的联系，发送者只需要知道如何发送请求命令即可，其余的可以一概不管，甚至命令是否成功都无需关心。同时我们可以非常方便的增加新的命令，但是对请求的封装会导致系统中会存在过多的具体命令类。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612022.png)

命令模式包含如下角色：
- Command: 抽象命令类
- ConcreteCommand: 具体命令类
- Invoker: 调用者
- Receiver: 接收者
- Client:客户类

## 23. 责任链模式
责任链模式描述的请求如何沿着对象所组成的链来传递的。它将对象组成一条链，发送者将请求发给链的第一个接收者，并且沿着这条链传递，直到有一个对象来处理它或者直到最后也没有对象处理而留在链末尾端。

责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。责任链模式，使得每一个对象都有可能来处理请求，从而实现了请求的发送者和接收者之间的解耦。同时职责链模式简化了对象的结构，它使得每个对象都只需要引用它的后继者即可，而不必了解整条链，这样既提高了系统的灵活性也使得增加新的请求处理类也比较方便。但是职责链不能保证所有的请求都能够被处理，而且不利于观察运行时特征。

![image](https://github.com/Airzihao/MDPicturePool/raw/master/201906/0612023.png)

职责链模式包含如下角色：
- Handler: 抽象处理者
- ConcreteHandler: 具体处理者
- Client: 客户类